# Itmo-csa-lab4

- Черемисова Мария P3210
- Вариант `lisp | acc | harv | mc | tick | binary | stream | port | pstr | prob2 | cache`
    - `lisp`: Синтаксис языка Lisp. S-exp:
        1. Поддержка рекурсивных функций.
        2. Любое выражение (statement) - expression.
    - `acc` : Система команд должна быть выстроена вокруг аккумулятора:
        1. Инструкции - изменяют значение, хранимое в аккумуляторе.
        2. Ввод-вывод осуществляется через аккумулятор.
    - `harv` : Гарвардская архитектура.
    - `mc` : Команды реализованы с помощью микрокоманд.
    - `tick` : Процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на
      любом такте.
    - `binary` : Бинарное представление машинного кода.
    - `stream` : Ввод-вывод осуществляется как поток токенов.
    - `port` : Port-mapped (специальные инструкции для ввода-вывода).
    - `pstr` : Length-prefixed (Pascal string).
    - `prob2` : Euler problem 6 [link](https://projecteuler.net/problem=6).
    - `cache` : Работа с памятью реализуется через кеш.
        - Скорость доступа к кешу - 1 такт, к памяти - 10 тактов.

# Язак lisp

Основн на S-выражениях, где весь код представляется так: каждая конструкция записывается в виде списка, заключённого в
круглые скобки, где первым элементом обычно является оператор или имя функции, а далее следуют аргументы. Ниже
представлена формальная грамматика (в стиле BNF) языка, основанного на Lisp, определяющая допустимые конструкции
программ.
```
<program> ::= <statement_list>

<statement_list> ::= <statement> | <statement> <statement_list>

<lvalue> ::= <identifier>

<statement> ::= <var_declaration>
              | <set_statement>
              | <if_statement>
              | <while_statement>
              | <defunc_declaration>
              | <function_call>
              | <print_string>
              | <read_line>

<var_declaration> ::= "(var" <identifier> <expression> ")"

<set_statement> ::= "(set" <lvalue> <expression> ")"

<if_statement> ::= "(if" <condition> <statement_list> <statement_list> ")"

<while_statement> ::= "(while" <condition> <statement_list> ")"

<defunc_declaration> ::= "(defunc" <identifier> "(" <parameter_list> ")" <statement_list> ")"

<function_call> ::= "(funcall" <identifier> "(" <argument_list> "))"

<print_string> ::= "(print_string" <string> ")"

<read_line> ::= "(read_line" <identifier> ")"

<condition> ::= "(" <comparison_operator> <expression> <expression> ")"

<comparison_operator> ::= ">" | "<" | "=" | "!="

<expression> ::= <number>
               | <identifier>
               | "(" <operator> <expression> <expression> ")"

<operator> ::= "+" | "-" | "*" | "/"

<parameter_list> ::= <identifier> | <identifier> <parameter_list>

<argument_list> ::= <expression> | <expression> <argument_list>

<identifier> ::= <letter> | <letter> <identifier_tail>

<identifier_tail> ::= <letter> | <digit> | <identifier_tail>

<string> ::= "\"" <string_content> "\""

<string_content> ::= <character> | <character> <string_content>

<character> ::= <letter> | <digit> | " " | "," | "!" | "?"

<letter> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"

<digit> ::= "0" | "1" | ... | "9"

<number> ::= <digit> | <digit> <number>
```

## Семантика

- Все выражения вычисляются по стратегии "сначала аргументы, затем оператор" (applicative order).
- Все выражения возвращают значения.
- Любое выражение или вызов функции всегда возвращают последнее вычисленное выражение.
- Выполнение программы начинается с первого выражения, не считая объявления функций.
- Переменные создаются через `var`, область видимости — глобальная и функциональная. Из функции невозможно обратиться к переменным извне, следует передавать их как аргументы.
- Имена переменных и функций чувствительны к регистру.
- `set` — присвоить переменной значение.
- `var` может использовать форму `(var arr [N])` — создаёт массив из `N` машинных слов.
- `if` вычисляет условие, затем один из блоков `statement_list`.
- `while` повторяет выполнение `statement_list`, пока условие истинно.
- `defunc` создаёт именованную функцию с параметрами и телом, поддерживается рекурсия.
- `funcall` вызывает ранее определённую функцию.
- `print_string` выводит строку (Pascal-формат).
- `read_line` — ввод строки в переменную, окончанием строки ожидается `\n`.
- Выражения арифметики (`+`, `-`, `*`, `/`) выполняются над числовыми значениями.

# Система Команд

## Используемые машинные команды
Размер инструкции 4 байта.

### `LOAD`

- **Синтаксис:** `LOAD addr`
- **Описание:** Загружает значение из памяти по адресу `addr` в аккумулятор (ACC) (абсолютная адресация).
- **Операция:** `ACC ← M[addr]`

---

### `LOAD_ADR`

- **Синтаксис:** `LOAD_ADR addr`
- **Описание:** Загружает значение из памяти по адресу, который находится в `addr` в аккумулятор (ACC) (косвенная адресация).
- **Операция:** `ACC ← M[M[addr]]`

---

### `STORE`

- **Синтаксис:** `STORE addr`
- **Описание:** Сохраняет содержимое аккумулятора в память по адресу `addr` (абсолютная адресация).
- **Операция:** `M[addr] ← ACC`

---

### `STORE_ADR`

- **Синтаксис:** `STORE_ADR addr`
- **Описание:** Сохраняет содержимое аккумулятора в память по адресу, который содержится в `addr` (косвенная адресация).
- **Операция:** `M[[addr]] ← ACC`

---


### `ADD`

- **Синтаксис:** `ADD addr`
- **Описание:** Складывает значение ACC и значение из памяти `addr`.
- **Операция:** `ACC ← ACC + M[addr]`

---

### `SUB`

- **Синтаксис:** `SUB addr`
- **Описание:** Вычитает значение из памяти `addr` из ACC.
- **Операция:** `ACC ← ACC - M[addr]`

---

### `MUL`

- **Синтаксис:** `MUL addr`
- **Описание:** Умножает ACC на значение из памяти `addr`.
- **Операция:** `ACC ← ACC * M[addr]`

---

### `DIV`

- **Синтаксис:** `DIV addr`
- **Описание:** Делит ACC на значение из памяти `addr`.
- **Операция:** `ACC ← ACC / M[addr]`

---

### `PUSH`

- **Синтаксис:** `PUSH`
- **Описание:** Помещает значение ACC в стек.
- **Операция:** `SP ← SP - 1; M[SP] ← ACC`

---

### `POP`

- **Синтаксис:** `POP addr`
- **Описание:** Извлекает значение из стека в `addr`.
- **Операция:** `addr ← M[SP]; SP ← SP + 1`

---

### `CALL`

- **Синтаксис:** `CALL label`
- **Описание:** Вызов подпрограммы по метке.
- **Операция:** `SP ← SP - 1; M[SP] ← PC; PC ← label`

---

### `RET`

- **Синтаксис:** `RET`
- **Описание:** Возврат из подпрограммы.
- **Операция:** `PC ← M[SP]; SP ← SP + 1`

---

### `JMP`

- **Синтаксис:** `JMP addr`
- **Описание:** Безусловный переход.
- **Операция:** `PC ← addr`

---

### `JZ`

- **Синтаксис:** `JZ addr`
- **Описание:** Переход, если ACC == 0.
- **Операция:** `if ACC == 0 then PC ← addr`

---

### `JNZ`

- **Синтаксис:** `JNZ addr`
- **Описание:** Переход, если ACC ≠ 0.
- **Операция:** `if ACC ≠ 0 then PC ← addr`

---

### `JLT`

- **Синтаксис:** `JLT addr`
- **Описание:** Переход, если ACC < 0.
- **Операция:** `if ACC < 0 then PC ← addr`

---

### `JGT`

- **Синтаксис:** `JGT addr`
- **Описание:** Переход, если ACC > 0.
- **Операция:** `if ACC > 0 then PC ← addr`

---

### `IN`

- **Синтаксис:** `IN port`
- **Описание:** Считывает байт из порта `port` в ACC.
- **Операция:** `ACC ← IN[port]`

---

### `OUT`

- **Синтаксис:** `OUT port`
- **Описание:** Записывает значение ACC в порт `port`.
- **Операция:** `OUT[port] ← ACC`

---

### `HALT`

- **Синтаксис:** `HALT`
- **Описание:** Останавливает выполнение программы.
- **Операция:** завершение выполнения

# Память
## Организация памяти
Модель памяти процессора:
- Память команд. Машинное слово -- 5 бит(команда) и 27 бит аргумент.
- Память данных. Машинное слово -- 32 бита, знаковое. 
- Линейное адресное пространство.
- Для вызова функций используется стек - в стек поинтере в момент запуска процессора хранится последняя ячейка памяти, стек растёт вниз.
- Для работы с памятью команд используются команды `load` и `store` для прямой адресации, `load_addr` и `store_addr` для косвенной адресации.
- Для перехода в памяти инструкций используется относительная адресация(относительно ip).

Program memory
+------------------------------+
| 00 : jump n                  |  ; Прыжок к инструкции под меткой _start
|   ...                        |
|  n : _start: instruction1    |
|   ...                        |
+------------------------------+

            Data memory
+------------------------------+
| n : const. (.word 42)        | ; Значение
+------------------------------+



## Кодирование инструкций
Размер команды 32 бита, 5 бит команда, остаток под аргументы.

| Команда   | Опкод (hex) |
|-----------|-------------|
| HALT      | 00000       | 
| LOAD_ADR  | 00001       |
| LOAD      | 00010       | 
| STORE     | 00011       | 
| STORE_ADR | 10100       |
| PUSH      | 00100       | 
| POP       | 00101       | 
| ADD       | 00110       | 
| SUB       | 00111       | 
| MUL       | 01000       | 
| DIV       | 01001       |
| CALL      | 01010       | 
| RET       | 01011       | 
| IN        | 01101       | 
| OUT       | 01110       | 
| JMP       | 01111       | 
| JZ        | 10000       | 
| JNZ       | 10001       | 
| JLT       | 10010       | 
| JGT       | 10011       | 


#Транслятор
```text
"Использование: python expr_to_asm.py <input.lisp> <output.bin>"
```
Работает в 3 прогона. На первой итерации мы рекурсивно парсим текст выделяя токены, получаем на выходе вложенные списки команд. На второй итерации мы превращаем эти команды в последовательности процессорных команд и алоцируем память под данные. На второй итерации так же расставляются адреса не лейблами, а адресами или смещениями. На третьей итерации мы записываем код в бинарный фаил.
### Структура бинарного файла
Заголовок:
Кол-во инструкций (4 байта)
Инструкции (по 4 байта каждая):
    - В формате: opcode(5 бит) | аргумент(27 бит)
Секция данных:
    - Каждая запись = адрес (3 байта) + значение (4 байта)
Реализовано с божьей помощью и слезами.

# Модель процессора
* аккумуляторная архитектура
* MC control unit
* port-mapped IO
* Остановка только по HALT

```text
"Использование: python cpu_sim.py <program.bin> <input.txt> <output.txt>"
```
Пример `program_dump` (в base64):
AAAAYHgAAAEIAAAAGAAAFhAAAAAwAAAXGAAAFBAAAAAwAAAXMAAAFhgAABUQAAAUOAAAFYAAAAcIAAAUcAAAABAAABQwAAAXGAAAFH////QQAAA7GAAAORAAABgwAAAXGAAAGGgAAAAYAAA9EAAAPTgAADqAAAALEAAAOTAAABgwAAAXGAAAPBAAAD2gAAA8EAAAOTAAABcYAAA5f///8hAAADmgAAAYCAAAPhgAAEkQAAA+MAAAFxgAAEcQAAA+MAAAFzAAAEkYAABIEAAARzgAAEiAAAAHCAAAR3AAAAAQAABHMAAAFxgAAEd////0CAAAGBgAAEwQAAAYMAAAFxgAAEoQAAAYMAAAFzAAAEwYAABLEAAASjgAAEuAAAAHCAAASnAAAAAQAABKMAAAFxgAAEp////0CAAATRgAAFIQAABNMAAAFxgAAFAQAABNMAAAFzAAAFIYAABREAAAUDgAAFGAAAAHCAAAUHAAAAAQAABQMAAAFxgAAFB////0AAAAAAAAAAAAAAABAAAAAQAAABIAAAACAAAAVwAAAAMAAABoAAAABAAAAGEAAAAFAAAAdAAAAAYAAAAgAAAABwAAAGkAAAAIAAAAcwAAAAkAAAAgAAAACgAAAHkAAAALAAAAbwAAAAwAAAB1AAAADQAAAHIAAAAOAAAAIAAAAA8AAABuAAAAEAAAAGEAAAARAAAAbQAAABIAAABlAAAAEwAAAD8AAAAXAAAAAQAAABgAAAAAAAAAOgAAAAoAAAA7AAAAAAAAADwAAAACAAAAPgAAAD8AAAA/AAAABwAAAEAAAABIAAAAQQAAAGUAAABCAAAAbAAAAEMAAABsAAAARAAAAG8AAABFAAAALAAAAEYAAAAgAAAATQAAAE4AAABOAAAAAQAAAE8AAAAh

Пример `input_file`:
Alice

Пример выполнения:

```text
  [TICK  1 (FETCH)] IP=0000 OPCODE=15
  ----------------------------------------
  [TICK 2] uPC=42 IR=78000001
  ACC=          0 DR=          0 IP=00000000 SP=7FFFFFFC
  DataA=0 Z=1 N=0
  ----------------------------------------
  [TICK 3] uPC=43 IR=78000001
  ACC=          0 DR=          0 IP=00000001 SP=7FFFFFFC
  DataA=0 Z=1 N=0
  ----------------------------------------
  [TICK 4] uPC=44 IR=78000001
  ACC=          0 DR=          0 IP=00000001 SP=7FFFFFFC
  DataA=0 Z=1 N=0
  ----------------------------------------
  [TICK 5] uPC=45 IR=78000001
  ACC=          0 DR=          0 IP=00000001 SP=7FFFFFFC
  DataA=0 Z=1 N=0
  ----------------------------------------
  [TICK  6 (FETCH)] IP=0001 OPCODE=01
  ----------------------------------------
  [TICK 7] uPC=55 IR=08000000
  ACC=          0 DR=          1 IP=00000001 SP=7FFFFFFC
  DataA=0 Z=1 N=0
  ----------------------------------------
  [TICK 8] uPC=56 IR=08000000
  ACC=          0 DR=          1 IP=00000001 SP=7FFFFFFC
  DataA=1 Z=1 N=0
  ----------------------------------------
  [TICK 9] uPC=57 IR=08000000
  ACC=          0 DR=         18 IP=00000001 SP=7FFFFFFC
  DataA=1 Z=1 N=0
  ----------------------------------------
  [TICK 10] uPC=58 IR=08000000
  ACC=         18 DR=         18 IP=00000001 SP=7FFFFFFC
  DataA=1 Z=0 N=0
  ----------------------------------------
  [TICK 11] uPC=59 IR=08000000
  ACC=         18 DR=         18 IP=00000002 SP=7FFFFFFC
  DataA=1 Z=0 N=0
  ----------------------------------------
  [TICK  12 (FETCH)] IP=0002 OPCODE=03
  ----------------------------------------
  [TICK 13] uPC=05 IR=18000016
  ACC=         18 DR=         18 IP=00000002 SP=7FFFFFFC
  DataA=22 Z=0 N=0
  ----------------------------------------
  [TICK 14] uPC=06 IR=18000016
  ACC=         18 DR=         18 IP=00000003 SP=7FFFFFFC
  DataA=22 Z=0 N=0
  ----------------------------------------
  [TICK 15] uPC=07 IR=18000016
  ACC=         18 DR=         18 IP=00000003 SP=7FFFFFFC
  DataA=22 Z=0 N=0
  ----------------------------------------
  ...
[87, 104, 97, 116, 32, 105, 115, 32, 121, 111, 117, 114, 32, 110, 97, 109, 101, 63, 72, 101, 108, 108, 111, 44, 32, 65, 108, 105, 99, 101, 33]
What is your name?
Hello,Alice!   
```
# Тестирование
Запустить тестирование

```text
poetry run pytest .
```

# Тесты
Логика работы тестирования - [test_golden.py](test_golden.py)
Каталог с тестам - [tests](tests)
- hello_word - выводит строку "o kak ".
- hello_user_name - печатает приветствие пользователю.
- cat - повторяет поток ввода в поток вывода.
- double_precision - складывает несколько чисел, резутат выводит как 64 битное число.
- euler_problem - вычисляет разницу между квадратом суммы первых 100 000 натуральных чисел и суммой квадратов этих чисел.
- tail_recursion - пример рекурсивной функции на lisp.
## DataPath
Сигналы:
1. Защелки
   - `data address latch`- защелкнуть адрес для Data memory
   - `memory latch` - защелкнуть данные в память по адресу
   - `data registry latch` - защелкнуть выход памяти в регистр данных
   -  `sp latch` - защелкнуть значение стек поинтера
   - `output latch` - защелкнуть данные в порт вывода
   - `IP latch` - защелкнуть данные в счетчик команд
   - `acc latch` - защёлкнуть значение acc
2. Управляющие
   - `address selector` - выбор адреса для памяти данных - либо напрямую из команды, либо из регистра данных
   - `io selector` - выбор записи в аккумулятор порта ввода или выхода алу
   - `cla` - левый вход алу - 0/AC/SP
   - `cld` - правый вход алу - 0/DR/IP
   - `IP selector` - выбор значения для счетчика команд - из CU(для прямого перехода) или  Alu(инкремент или косвенный переход)
   - `alu control` - сложение/вычитание/деление/умножение/increment/decrement
### АЛУ
Алу способно проводить все 4 арифметические операции - умножение, сложение, вычитание и деление, а так же инкремент и декремент.  
Условно считается, что все операции производятся комбинационной схемой за 1 такт.
### Флаги
`N` и `Z` - соответственно если 32-й бит == 1 и если результат == 0  
привязаны к алу и выставляются соответственно значению в нем после выполнения операции
![Аккумуляторная схема](/img/processor.png)

# Микрокоманды
Размер микрокоманды 27 бит.

| Бит   | Сигнал              | Допустимые коды                                           |
|-------|---------------------|-----------------------------------------------------------|
| 26    | halted              | остановка машины                                          | 
| 25    | acc latch           | 1 = защёлкнуть запись в аккумулятор                       |
| 24    | data address latch  | 1 = защёлкнуть Data Adr                                   |
| 23    | memory latch        | 1 = защёлкнуть Данные в память по адресу                  |
| 22    | sp latch            | 1 = защёлкнуть SP                                         |
| 21    | data registry latch | 1 = DR  ← MEM[Data Adr]                                   |
| 20    | output latch        | 1 = OUTPUT-порт                                           |
| 19    | IP latch            | 1 = записать новое IP                                     |
| 18    | address selector    | 0 = из opcode, 1 = из ACC                                 |
| 17    | io selector         | 0 = ALU → ACC, 1 = INPUT → ACC  (через ALU)               |
| 16-15 | cla (левый ALU)     | 00 = 0, 01 = ACC, 10 = SP                                 |
| 14-13 | cld (правый ALU)    | 00 = 0, 01 = DR, 10 = IP                                  |
| 12    | IP selector         | 00 = IP 01 = CU                                           |                         
| 11-9  | alu control         | 000 ADD · 001 SUB · 010 MUL · 011 DIV · 100 INC · 101 DEC |
| 8-6   | cond                | режим работы модуля условий                               |
| 5-0   | next_addr           | 6-бит адрес следующей микро-команды (0…63)                |

## Control unit
Представляет из себя декодер, регистры для хранения микрокоманды и её, память микрокоманд, а так же отдельный модуль условий, который получая на вход флаги N и Z, а так же режим работы выдаёт 0 или 1. 

Для выбора адреса следующей микрокоманды мы руководствуемся выходом из модуля условий, на его основе совершается решение инкрементировать значение адреса или перепрыгнуть по другому адресу. 

У модуля условий есть несколько режимов:

| Биты | Условие    | Описание               |
|------|------------|------------------------|
| 000  | `NONE`     | Условие всегда ложно   |
| 001  | `TRUE`     | Условие всегда истинно |  
| 010  | `ZERO`     | Флаг Z == 1            |
| 011  | `GREATER`  | N != 0 and Z != 0      |
| 100  | `NOT_ZERO` | Z == 0                 |
| 101  | `LOWER`    | N == 0 and Z != 0      |

Так же декодер отделяет команду от её аргументов и отправляет аргументы на регистры.
![Control unit](/img/cu.png)

#Пример использования
```text
(.venv) C:\Users\chenqing\PycharmProjects\cs-ak-lab4>python expr_to_asm.py lisp\tail_recursion\tail_recursion.lisp outp.bin

(.venv) C:\Users\chenqing\PycharmProjects\cs-ak-lab4>python cpu_sim.py outp.bin lisp\tail_recursion\input.txt lisp\tail_recursion\output.txt
[OUT]: 57
[OUT]: 56
[OUT]: 55
[OUT]: 54
[OUT]: 53
[OUT]: 52
[OUT]: 51
[OUT]: 50
[OUT]: 49

0000 - 7800001D - jmp 29
0001 - 10000001 - load 1
0002 - 10000000 - load 0
0003 - 20000000 - push
0004 - 10000003 - load 3
0005 - 18000004 - store 4
0006 - 28000000 - pop
0007 - 30000004 - add 4
0008 - 18000001 - store 1
0009 - 10000001 - load 1
0010 - 70000000 - out 0
0011 - 10000000 - load 0
0012 - 20000000 - push
0013 - 10000005 - load 5
0014 - 18000006 - store 6
0015 - 28000000 - pop
0016 - 38000006 - sub 6
0017 - 18000000 - store 0
0018 - 10000000 - load 0
0019 - 20000000 - push
0020 - 10000002 - load 2
0021 - 18000007 - store 7
0022 - 28000000 - pop
0023 - 38000007 - sub 7
0024 - 80000004 - jz 4
0025 - 10000000 - load 0
0026 - 18000000 - store 0
0027 - 57FFFFE6 - call -26
0028 - 58000000 - ret
0029 - 10000008 - load 8
0030 - 18000000 - store 0
0031 - 57FFFFE2 - call -30
0032 - 00000000 - halt

[TICK  1 (FETCH)] IP=0000 OPCODE=15
----------------------------------------
[TICK 2] uPC=42 IR=7800001D
ACC=          0 DR=          0 IP=00000000 SP=7FFFFFFC
DataA=0 Z=1 N=0
----------------------------------------
[TICK 3] uPC=43 IR=7800001D
ACC=          0 DR=          0 IP=0000001D SP=7FFFFFFC
DataA=0 Z=1 N=0
----------------------------------------
[TICK 4] uPC=44 IR=7800001D
ACC=          0 DR=          0 IP=0000001D SP=7FFFFFFC
DataA=0 Z=1 N=0
----------------------------------------
[TICK 5] uPC=45 IR=7800001D
ACC=          0 DR=          0 IP=0000001D SP=7FFFFFFC
DataA=0 Z=1 N=0
----------------------------------------
[TICK  6 (FETCH)] IP=0029 OPCODE=02
----------------------------------------
[TICK 7] uPC=01 IR=10000008
ACC=          0 DR=          9 IP=0000001D SP=7FFFFFFC
DataA=8 Z=1 N=0
----------------------------------------
[TICK 8] uPC=02 IR=10000008
ACC=          9 DR=          9 IP=0000001D SP=7FFFFFFC
DataA=8 Z=0 N=0
----------------------------------------
[TICK 9] uPC=03 IR=10000008
ACC=          9 DR=          9 IP=0000001E SP=7FFFFFFC
DataA=8 Z=0 N=0
----------------------------------------
[TICK 10] uPC=04 IR=10000008
ACC=          9 DR=          9 IP=0000001E SP=7FFFFFFC
DataA=8 Z=0 N=0
----------------------------------------
...
----------------------------------------
[TICK  1214 (FETCH)] IP=0028 OPCODE=11
----------------------------------------
[TICK 1215] uPC=11 IR=58000000
ACC=         24 DR=         28 IP=0000001C SP=7FFFFFFA
DataA=2147483642 Z=0 N=0
----------------------------------------
[TICK 1216] uPC=12 IR=58000000
ACC=         24 DR=         28 IP=0000001C SP=7FFFFFFA
DataA=2147483642 Z=0 N=0
----------------------------------------
[TICK 1217] uPC=13 IR=58000000
ACC=         24 DR=         28 IP=0000001C SP=7FFFFFFB
DataA=2147483642 Z=0 N=0
----------------------------------------
[TICK 1218] uPC=14 IR=58000000
ACC=         24 DR=         28 IP=0000001C SP=7FFFFFFB
DataA=2147483642 Z=0 N=0
----------------------------------------
[TICK  1219 (FETCH)] IP=0028 OPCODE=11
----------------------------------------
[TICK 1220] uPC=11 IR=58000000
ACC=         24 DR=         32 IP=0000001C SP=7FFFFFFB
DataA=2147483643 Z=0 N=0
----------------------------------------
[TICK 1221] uPC=12 IR=58000000
ACC=         24 DR=         32 IP=00000020 SP=7FFFFFFB
DataA=2147483643 Z=0 N=0
----------------------------------------
[TICK 1222] uPC=13 IR=58000000
ACC=         24 DR=         32 IP=00000020 SP=7FFFFFFC
DataA=2147483643 Z=0 N=0
----------------------------------------
[TICK 1223] uPC=14 IR=58000000
ACC=         24 DR=         32 IP=00000020 SP=7FFFFFFC
DataA=2147483643 Z=0 N=0
----------------------------------------
[TICK  1224 (FETCH)] IP=0032 OPCODE=00
----------------------------------------
[TICK 1225] uPC=54 IR=00000000
ACC=         24 DR=         32 IP=00000020 SP=7FFFFFFC
DataA=2147483643 Z=0 N=0
----------------------------------------
```
