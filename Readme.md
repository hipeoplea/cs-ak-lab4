# Itmo-csa-lab4

- Черемисова Мария P3210
- Вариант `lisp | acc | harv | mc | tick | binary | stream | port | pstr | prob2 | cache`
    - `lisp`: Синтаксис языка Lisp. S-exp:
        1. Поддержка рекурсивных функций.
        2. Любое выражение (statement) - expression.
    - `acc` : Система команд должна быть выстроена вокруг аккумулятора:
        1. Инструкции - изменяют значение, хранимое в аккумуляторе.
        2. Ввод-вывод осуществляется через аккумулятор.
    - `harv` : Гарвардская архитектура.
    - `mc` : Команды реализованы с помощью микрокоманд.
    - `tick` : Процессор необходимо моделировать с точностью до такта, процесс моделирования может быть приостановлен на
      любом такте.
    - `binary` : Бинарное представление машинного кода.
    - `stream` : Ввод-вывод осуществляется как поток токенов.
    - `port` : Port-mapped (специальные инструкции для ввода-вывода), да я портовая шлюха.
    - `pstr` : Length-prefixed (Pascal string).
    - `prob2` : Euler problem 6 [link](https://projecteuler.net/problem=6).
    - `cache` : Работа с памятью реализуется через кеш.
        - Скорость доступа к кешу - 1 такт, к памяти - 10 тактов.

# Язак lisp

Основн на S-выражениях, где весь код представляется так: каждая конструкция записывается в виде списка, заключённого в
круглые скобки, где первым элементом обычно является оператор или имя функции, а далее следуют аргументы. Ниже
представлена формальная грамматика (в стиле BNF) языка, основанного на Lisp, определяющая допустимые конструкции
программ.
```
<program> ::= <statement_list>

<statement_list> ::= <statement> | <statement> <statement_list>

<lvalue> ::= <identifier>

<statement> ::= <var_declaration>
              | <set_statement>
              | <if_statement>
              | <while_statement>
              | <defunc_declaration>
              | <function_call>
              | <print_string>
              | <read_line>

<var_declaration> ::= "(var" <identifier> <expression> ")"

<set_statement> ::= "(set" <lvalue> <expression> ")"

<if_statement> ::= "(if" <condition> <statement_list> <statement_list> ")"

<while_statement> ::= "(while" <condition> <statement_list> ")"

<defunc_declaration> ::= "(defunc" <identifier> "(" <parameter_list> ")" <statement_list> ")"

<function_call> ::= "(funcall" <identifier> "(" <argument_list> "))"

<print_string> ::= "(print_string" <string> ")"

<read_line> ::= "(read_line" <identifier> ")"

<condition> ::= "(" <comparison_operator> <expression> <expression> ")"

<comparison_operator> ::= ">" | "<" | "=" | "!="

<expression> ::= <number>
               | <identifier>
               | "(" <operator> <expression> <expression> ")"

<operator> ::= "+" | "-" | "*" | "/"

<parameter_list> ::= <identifier> | <identifier> <parameter_list>

<argument_list> ::= <expression> | <expression> <argument_list>

<identifier> ::= <letter> | <letter> <identifier_tail>

<identifier_tail> ::= <letter> | <digit> | <identifier_tail>

<string> ::= "\"" <string_content> "\""

<string_content> ::= <character> | <character> <string_content>

<character> ::= <letter> | <digit> | " " | "," | "!" | "?"

<letter> ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"

<digit> ::= "0" | "1" | ... | "9"

<number> ::= <digit> | <digit> <number>
```

## Семантика

- Все выражения вычисляются по стратегии "сначала аргументы, затем оператор" (applicative order).
- Все выражения возвращают значения.
- Любое выражение или вызов функции всегда возвращают последнее вычисленное выражение.
- Выполнение программы начинается с первого выражения, не считая объявления функций.
- Переменные создаются через `var`, область видимости — глобальная и функциональная. Из функции невозможно обратиться к переменным извне, следует передавать их как аргументы.
- Имена переменных и функций чувствительны к регистру.
- `set` — присвоить переменной значение.
- `var` может использовать форму `(var arr [N])` — создаёт массив из `N` машинных слов.
- `if` вычисляет условие, затем один из блоков `statement_list`.
- `while` повторяет выполнение `statement_list`, пока условие истинно.
- `defunc` создаёт именованную функцию с параметрами и телом, поддерживается рекурсия.
- `funcall` вызывает ранее определённую функцию.
- `print_string` выводит строку (Pascal-формат).
- `read_line` — ввод строки в переменную, окончанием строки ожидается `\n`.
- Выражения арифметики (`+`, `-`, `*`, `/`) выполняются над числовыми значениями.

# Система Команд

## Используемые машинные команды

### `LOAD`

- **Синтаксис:** `LOAD addr`
- **Описание:** Загружает значение из памяти по адресу `addr` в аккумулятор (ACC) (абсолютная адресация).
- **Операция:** `ACC ← M[addr]`

---

### `LOAD_ADR`

- **Синтаксис:** `LOAD_ADR addr`
- **Описание:** Загружает значение из памяти по адресу, который находится в `addr` в аккумулятор (ACC) (косвенная адресация).
- **Операция:** `ACC ← M[M[addr]]`

---

### `STORE`

- **Синтаксис:** `STORE addr`
- **Описание:** Сохраняет содержимое аккумулятора в память по адресу `addr` (абсолютная адресация).
- **Операция:** `M[addr] ← ACC`

---

### `STORE_ADR`

- **Синтаксис:** `STORE_ADR addr`
- **Описание:** Сохраняет содержимое аккумулятора в память по адресу, который содержится в `addr` (косвенная адресация).
- **Операция:** `M[[addr]] ← ACC`

---


### `ADD`

- **Синтаксис:** `ADD addr`
- **Описание:** Складывает значение ACC и значение из памяти `addr`.
- **Операция:** `ACC ← ACC + M[addr]`

---

### `SUB`

- **Синтаксис:** `SUB addr`
- **Описание:** Вычитает значение из памяти `addr` из ACC.
- **Операция:** `ACC ← ACC - M[addr]`

---

### `MUL`

- **Синтаксис:** `MUL addr`
- **Описание:** Умножает ACC на значение из памяти `addr`.
- **Операция:** `ACC ← ACC * M[addr]`

---

### `DIV`

- **Синтаксис:** `DIV addr`
- **Описание:** Делит ACC на значение из памяти `addr`.
- **Операция:** `ACC ← ACC / M[addr]`

---

### `PUSH`

- **Синтаксис:** `PUSH`
- **Описание:** Помещает значение ACC в стек.
- **Операция:** `SP ← SP - 1; M[SP] ← ACC`

---

### `POP`

- **Синтаксис:** `POP addr`
- **Описание:** Извлекает значение из стека в `addr`.
- **Операция:** `addr ← M[SP]; SP ← SP + 1`

---

### `CALL`

- **Синтаксис:** `CALL label`
- **Описание:** Вызов подпрограммы по метке.
- **Операция:** `SP ← SP - 1; M[SP] ← PC; PC ← label`

---

### `RET`

- **Синтаксис:** `RET`
- **Описание:** Возврат из подпрограммы.
- **Операция:** `PC ← M[SP]; SP ← SP + 1`

---

### `JMP`

- **Синтаксис:** `JMP addr`
- **Описание:** Безусловный переход.
- **Операция:** `PC ← addr`

---

### `JZ`

- **Синтаксис:** `JZ addr`
- **Описание:** Переход, если ACC == 0.
- **Операция:** `if ACC == 0 then PC ← addr`

---

### `JNZ`

- **Синтаксис:** `JNZ addr`
- **Описание:** Переход, если ACC ≠ 0.
- **Операция:** `if ACC ≠ 0 then PC ← addr`

---

### `JLT`

- **Синтаксис:** `JLT addr`
- **Описание:** Переход, если ACC < 0.
- **Операция:** `if ACC < 0 then PC ← addr`

---

### `JGT`

- **Синтаксис:** `JGT addr`
- **Описание:** Переход, если ACC > 0.
- **Операция:** `if ACC > 0 then PC ← addr`

---

### `IN`

- **Синтаксис:** `IN port`
- **Описание:** Считывает байт из порта `port` в ACC.
- **Операция:** `ACC ← IN[port]`

---

### `OUT`

- **Синтаксис:** `OUT port`
- **Описание:** Записывает значение ACC в порт `port`.
- **Операция:** `OUT[port] ← ACC`

---

### `HALT`

- **Синтаксис:** `HALT`
- **Описание:** Останавливает выполнение программы.
- **Операция:** завершение выполнения

# Память
## Организация памяти
Модель памяти процессора:
Память команд. Машинное слово -- 5 бит(команда) и 18. Реализуется списком словарей, описывающих инструкции (одно слово -- одна ячейка).
Память данных. Машинное слово -- 32 бита, знаковое. Линейное адресное пространство. Реализуется списком чисел.
Для вызова функций используется стек - в стек поинтере в момент запуска процессора хранится последняя ячейка памяти, стек растёт вниз. 

Память данных условно разделена на 3 части

0-256 - под переменные и статику.
256-512 - буферная память, выделяется компилятором для сохранения
промежуточных результатов вычислений, когда регистров не хватает для алгоритма,
а в нашем случае это примерно каждая операция, так как регистр у нас всего один.
512-1024 - стек, стек растет вниз.

## Кодирование инструкций
Размер команды 32 бита, 5 бит команда, остаток под аргументы

| Команда   | Опкод (hex) |
|-----------|-------------|
| HALT      | 00000       | 
| LOAD_ADR  | 00001       |
| LOAD      | 00010       | 
| STORE     | 00011       | 
| STORE_ADR | 10100       |
| PUSH      | 00100       | 
| POP       | 00101       | 
| ADD       | 00110       | 
| SUB       | 00111       | 
| MUL       | 01000       | 
| DIV       | 01001       |
| CALL      | 01010       | 
| RET       | 01011       | 
| IN        | 01101       | 
| OUT       | 01110       | 
| JMP       | 01111       | 
| JZ        | 10000       | 
| JNZ       | 10001       | 
| JLT       | 10010       | 
| JGT       | 10011       | 

# Микрокоманды
Размер микрокоманды 27 бит,

| Бит   | Сигнал              | Допустимые коды                                           |
|-------|---------------------|-----------------------------------------------------------|
| 26    | halted              | остановка машины                                          | 
| 25    | acc latch           | 1 = защёлкнуть запись в аккумулятор                       |
| 24    | data address latch  | 1 = защёлкнуть Data Adr                                   |
| 23    | memory latch        | 1 = защёлкнуть Данные в память по адресу                  |
| 22    | sp latch            | 1 = защёлкнуть SP                                         |
| 21    | data registry latch | 1 = DR  ← MEM[Data Adr]                                   |
| 20    | output latch        | 1 = OUTPUT-порт                                           |
| 19    | IP latch            | 1 = записать новое IP                                     |
| 18    | address selector    | 0 = из opcode, 1 = из ACC                                 |
| 17    | io selector         | 0 = ALU → ACC, 1 = INPUT → ACC  (через ALU)               |
| 16-15 | cla (левый ALU)     | 00 = 0, 01 = ACC, 10 = SP                                 |
| 14-13 | cld (правый ALU)    | 00 = 0, 01 = DR, 10 = IP                                  |
| 12    | IP selector         | 00 = IP 01 = CU                                           |                         
| 11-9  | alu control         | 000 ADD · 001 SUB · 010 MUL · 011 DIV · 100 INC · 101 DEC |
| 8-6   | cond                | режим работы модуля условий                               |
| 5-0   | next_addr           | 6-бит адрес следующей микро-команды (0…63)                |

# Модель процессора
* аккумуляторная архитектура
* MC control unit
* port-mapped IO
* Остановка только по HALT

## DataPath
Сигналы:
1. Защелки
   - `data address latch`- защелкнуть адрес для Data memory
   - `memory latch` - защелкнуть данные в память по адресу
   - `data registry latch` - защелкнуть выход памяти в регистр данных
   -  `sp latch` - защелкнуть значение стек поинтера
   - `output latch` - защелкнуть данные в порт вывода
   - `IP latch` - защелкнуть данные в счетчик команд
   - `acc latch` - защёлкнуть значение acc
2. Управляющие
   - `address selector` - выбор адреса для памяти данных - либо напрямую из команды, либо из регистра данных
   - `io selector` - выбор записи в аккумулятор порта ввода или выхода алу
   - `cla` - левый вход алу - 0/AC/SP
   - `cld` - правый вход алу - 0/DR/IP
   - `IP selector` - выбор значения для счетчика команд - из CU(для прямого перехода) или  Alu(инкремент или косвенный переход)
   - `alu control` - сложение/вычитание/деление/умножение/increment/decrement
### АЛУ
Алу способно проводить все 4 арифметические операции - умножение, сложение, вычитание и деление.  
Условно считается, что все операции производятся комбинационной схемой за 1 такт.
### Флаги
`N` и `Z` - соответственно если 32-й бит == 1 и если результат == 0  
привязаны к алу и выставляются соответственно значению в нем после выполнения операции
![Аккумуляторная схема](/img/processor.png)
## Control unit
Представляет из себя декодер, регистры для хранения микрокоманды и её, память микрокоманд, а так же отдельный модуль условий, который получая на вход флаги N и Z, а так же режим работы выдаёт 0 или 1. 

Для выбора адреса следующей микрокоманды мы руководствуемся выходом из модуля условий, на его основе совершается решение инкрементировать значение адреса или перепрыгнуть по другому адресу. 

У модуля условий есть несколько режимов:

| Биты | Условие    | Описание               |
|------|------------|------------------------|
| 000  | `NONE`     | Условие всегда ложно   |
| 001  | `TRUE`     | Условие всегда истинно |  
| 010  | `ZERO`     | Флаг Z == 1            |
| 011  | `GREATER`  | N != 0 and Z != 0      |
| 100  | `NOT_ZERO` | Z == 0                 |
| 101  | `LOWER`    | N == 0 and Z != 0      |

Так же декодер отделяет команду от её аргументов и отправляет аргументы на регистры.
![Control unit](/img/cu.png)
